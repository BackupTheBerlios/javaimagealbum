/*
 * <license>
 * The contents of this file are subject to the Mozilla Public License 
 * Version 1.1 (the "License"); you may not use this file except in 
 * compliance with the License.  You may obtain a copy of the License 
 * at http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an 
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or 
 * implied. See the License for the specific language governing rights 
 * and limitations under the License.
 * 
 * The Original Code is Web Photo Publisher.
 * 
 * The Initial Developer of the Original Code is Mark Roth.  Portions 
 * created by Mark Roth are Copyright (C) 2003 Mark Roth.  
 * All Rights Reserved.
 * 
 * Contributor(s) listed below.
 * </license>
 */

package com.javaimagealbum;

import javax.swing.tree.*;
import javax.swing.*;
import java.util.*;
import java.io.*;
import java.awt.*;
import java.awt.event.*;

/**
 * Inline panel that allows file / directory selection.  Image is
 * rendered as a tree panel.  Currently, only single selection is supported.
 *
 * @author  mroth
 */
public class FileSelector 
    extends javax.swing.JPanel 
    implements ItemSelectable
{

    /** True if only directories are to be displayed. */
    private boolean directoriesOnly;
    
    /** 
     * Creates new form FileSelector 
     * 
     * @param directoriesOnly If true, only directories will be displayed.
     */
    public FileSelector( boolean directoriesOnly ) {
    	super();
        this.directoriesOnly = directoriesOnly;
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        trFileTree = new javax.swing.JTree();
        trFileTree.setModel(
            new DefaultTreeModel(
                new RootTreeNode( directoriesOnly ) ) );

            setLayout(new java.awt.BorderLayout());

            trFileTree.setRootVisible(false);
            trFileTree.setAutoscrolls(true);
            TreeSelectionModel model = trFileTree.getSelectionModel();
            model.setSelectionMode( TreeSelectionModel.SINGLE_TREE_SELECTION );

            trFileTree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
                public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                    trFileTreeValueChanged(evt);
                }
            });

            add(trFileTree, java.awt.BorderLayout.CENTER);

        }//GEN-END:initComponents

    private void trFileTreeValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_trFileTreeValueChanged
        File selectedFile = getSelectedFile();
        ItemEvent event;
        if( selectedFile == null ) {
            event = new ItemEvent( this, ItemEvent.DESELECTED, 
                null, ItemEvent.ITEM_STATE_CHANGED );
        }
        else {
            event = new ItemEvent( this, ItemEvent.SELECTED, 
                selectedFile, ItemEvent.ITEM_STATE_CHANGED );
        }
        fireItemListenerItemStateChanged( event );
    }//GEN-LAST:event_trFileTreeValueChanged


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTree trFileTree;
    // End of variables declaration//GEN-END:variables

    /** Utility field used by event firing mechanism. */
    private javax.swing.event.EventListenerList listenerList = null;
    
    /**
     * Sets the selected file to the given file
     */
    public void setSelectedFile( File f ) {
        Stack composition = new Stack();
        do {
            File parent = f.getParentFile();
            String name = f.getName();
            if( parent == null ) {
                // If this is a root filename, use toString instead of getName.
                name = f.toString();
            }
            composition.push( name );
            f = parent;
        } while( f != null );
        
        DefaultTreeModel model = (DefaultTreeModel)trFileTree.getModel();
        TreeNode node = (TreeNode)model.getRoot();
        TreePath path = new TreePath( model.getRoot() );
        String name;
        while( !composition.empty() && 
            (name = (String)composition.pop()) != null ) 
        {
            if( name.equals( "" ) ) {
                name = "/";
            }
            Enumeration children = node.children();
            TreeNode found = null;
            while( children.hasMoreElements() ) {
                TreeNode child = (TreeNode)children.nextElement();
                if( child.toString().equals( name ) ) {
                    found = child;
                }
            }
            if( found != null ) {
                path = path.pathByAddingChild( found );
                node = found;
            }
            else {
                break;
            }
        }
        trFileTree.setSelectionPath( path );
        trFileTree.invalidate();
        //trFileTree.validate();
        scrollToSelection();
        trFileTree.repaint();
    }
    
    /**
     * Ensure the currently selected file is visible
     */
    public void scrollToSelection() {
        trFileTree.scrollPathToVisible( trFileTree.getSelectionPath() );
    }
    
    /**
     * Refreshes the current selection (appropriate when, for example,
     * a new folder is created as a subfolder).
     */
    public void refreshSelection() {
        TreePath selection = trFileTree.getSelectionPath();
        if( selection != null ) {
            TreeNode node = (TreeNode)selection.getLastPathComponent();
            if( node instanceof RootTreeNode ) {
                ((RootTreeNode)node).refresh();
            }
            else if( node instanceof DirectoryTreeNode ) {
                ((DirectoryTreeNode)node).refresh();
            }
            else if( node instanceof FileTreeNode ) {
                ((FileTreeNode)node).refresh();
            }
            ((DefaultTreeModel)trFileTree.getModel()).nodeStructureChanged( 
                node );
        }
    }
    
    /**
     * Returns the file currently selected, or null if none.
     */
    public File getSelectedFile() {
        File result = null;
        TreePath selectionPath = trFileTree.getSelectionPath();
        if( selectionPath != null ) {
            TreeNode node = (TreeNode)selectionPath.getLastPathComponent();
            if( node instanceof RootTreeNode ) {
                result = null;
            }
            else if( node instanceof DirectoryTreeNode ) {
                result = ((DirectoryTreeNode)node).getDirectory();
            }
            else if( node instanceof FileTreeNode ) {
                result = ((FileTreeNode)node).getFile();
            }
        }
        return result;
    }
    
    private static final class RootTreeNode 
        implements TreeNode 
    {
        /** Root filesystems */
        private File[] roots;
        
        /** If true, only directories are displayed */
        private boolean directoriesOnly;
        
        /** Cached tree nodes for root */
        private TreeNode[] fileTreeNode;
        
        public RootTreeNode( boolean directoriesOnly ) {
            this.directoriesOnly = directoriesOnly;
            refresh();
        }
        
        public int getIndex(javax.swing.tree.TreeNode treeNode) {
            int found = -1;
            for( int i = 0; (found == -1) && (i < fileTreeNode.length); i++ ) {
                if( fileTreeNode[i] == treeNode ) found = i;
            }
            return found;
        }
        
        public javax.swing.tree.TreeNode getParent() {
            return null;
        }
        
        public java.util.Enumeration children() {
            Vector v = new Vector( fileTreeNode.length );
            for( int i = 0; i < fileTreeNode.length; i++ ) {
                v.addElement( fileTreeNode[i] );
            }
            return v.elements();
        }
        
        public int getChildCount() {
            return fileTreeNode.length;
        }
        
        public boolean getAllowsChildren() {
            return fileTreeNode.length > 0;
        }
        
        public javax.swing.tree.TreeNode getChildAt(int param) {
            return fileTreeNode[param];
        }
        
        public boolean isLeaf() {
            return fileTreeNode.length == 0;
        }
        
        public void refresh() {
            roots = File.listRoots();
            fileTreeNode = new TreeNode[roots.length];
            for( int i = 0; i < roots.length; i++ ) {
                fileTreeNode[i] = new DirectoryTreeNode( this, roots[i],
                    true, directoriesOnly );
            }
        }
        
        public String toString() {
            return "Root";
        }
        
    }
    
    /**
     * Tree node that represents a directory
     */
    private static final class DirectoryTreeNode 
        implements TreeNode 
    {
        /** Parent tree node */
        private TreeNode parent;
        
        /** If true, only directories are displayed */
        private boolean directoriesOnly;
        
        /** If true, this is a root directory. */
        private boolean isRoot;
        
        /** This directory */
        private File dir;
        
        /** Contents */
        private String[] contents;
        
        /** Cached tree nodes for root */
        private TreeNode[] children;
        
        public DirectoryTreeNode( TreeNode parent, File dir, 
            boolean isRoot, boolean directoriesOnly ) 
        {
            this.parent = parent;
            this.dir = dir;
            this.isRoot = isRoot;
            this.directoriesOnly = directoriesOnly;
        }
        
        private TreeNode[] getTreeNodes() {
            if( children == null ) {
                synchronized ( this ) {
                    if( directoriesOnly ) {
                        contents = dir.list( 
                            new FilenameFilter() {
                                public boolean accept( File dir, String file ) {
                                    return new File( dir, file ).isDirectory();
                                }
                            } );
                    }
                    else {
                        contents = dir.list();
                    }
                    // This may happen if we have no permissions, e.g.
                    if( contents == null ) contents = new String[0];
                    children = new TreeNode[contents.length];
                    for( int i = 0; i < contents.length; i++ ) {
                        File file = new File( dir, contents[i] );
                        if( file.isDirectory() ) {
                            children[i] = new DirectoryTreeNode( this, file,
                                false, directoriesOnly );
                        }
                        else {
                            children[i] = new FileTreeNode( this, file );
                        }
                    }
                }
            }
            return children;
        }
        
        public int getIndex(javax.swing.tree.TreeNode treeNode) {
            TreeNode[] treenodes = getTreeNodes();
            int found = -1;
            for( int i = 0; (found == -1) && (i < treenodes.length); i++ ) {
                if( treenodes[i] == treeNode ) found = i;
            }
            return found;
        }
        
        public javax.swing.tree.TreeNode getParent() {
            return parent;
        }
        
        public java.util.Enumeration children() {
            TreeNode[] treenodes = getTreeNodes();
            Vector v = new Vector( treenodes.length );
            for( int i = 0; i < treenodes.length; i++ ) {
                v.addElement( treenodes[i] );
            }
            return v.elements();
        }
        
        public int getChildCount() {
            return getTreeNodes().length;
        }
        
        public boolean getAllowsChildren() {
            return true;
        }
        
        public javax.swing.tree.TreeNode getChildAt(int param) {
            return getTreeNodes()[param];
        }
        
        public boolean isLeaf() {
            // For optimization, so we need not retrieve children all
            // the time:
            return false;
        }
        
        public String toString() {
            String result;
            
            if( isRoot ) {
                // Root directories don't return any value for getName()
                // on Windows especially.  However, we can use
                // toString():
                result = dir.toString();
            }
            else {
                result = dir.getName();
            }

            // Just in case we still don't have a name, call it "/"
            if( result.equals( "" ) ) result = "/";
            
            return result;
        }
        
        public File getDirectory() {
            return dir;
        }
        
        public void refresh() {
            children = null;
        }
        
    }

    /**
     * Tree node that represents a file
     */
    private static final class FileTreeNode 
        implements TreeNode 
    {    
        /** The parent of this treenode */
        private TreeNode parent;
        
        /** The file this tree node represents */
        private File file;
        
        public FileTreeNode( TreeNode parent, File file ) {
            this.parent = parent;
            this.file = file;
        }
        
        public int getIndex(javax.swing.tree.TreeNode treeNode) {
            return -1;
        }
        
        public javax.swing.tree.TreeNode getParent() {
            return parent;
        }
        
        public java.util.Enumeration children() {
            return new Vector( 0 ).elements();
        }
        
        public int getChildCount() {
            return 0;
        }
        
        public boolean getAllowsChildren() {
            return false;
        }
        
        public javax.swing.tree.TreeNode getChildAt(int param) {
            return null;
        }
        
        public boolean isLeaf() {
            return true;
        }
        
        public String toString() {
            return file.getName();
        }
        
        public File getFile() {
            return file;
        }
        
        public void refresh() {
        }
    }

    
    /** Test it out */
    public static void main( final String[] args ) {
        FileSelector fs = new FileSelector( true );
        JFrame f = new JFrame();
        f.setSize( 640, 480 );
        JScrollPane scrollPane = new JScrollPane();
        scrollPane.setViewportView( fs );
        f.getContentPane().add( scrollPane );
        f.setVisible( true );
        f.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );    
        try {
            Thread.sleep( 2000 );
        }
        catch( InterruptedException e ) {
        }
        fs.setSelectedFile( new File( "/home/mroth/webphotopublish/foo/bar" ) );
        try {
            Thread.sleep( 2000 );
        }
        catch( InterruptedException e ) {
        }
        fs.scrollToSelection();
        do {
            System.out.println( "Selected = " + 
                fs.getSelectedFile().getAbsolutePath() );
            try {
                Thread.sleep( 1000 );
            }
            catch( InterruptedException e ) {
            }
        } while( true );
    }
    
    public Object[] getSelectedObjects() {
        Object[] result = null;
        File file = getSelectedFile();
        if( file != null ) {
            result = new Object[1];
            result[0] = file;
        }
        return result;
    }
    
    /** Registers ItemListener to receive events.
     * @param listener The listener to register.
     */
    public synchronized void addItemListener(java.awt.event.ItemListener listener) {
        if (listenerList == null ) {
            listenerList = new javax.swing.event.EventListenerList();
        }
        listenerList.add(java.awt.event.ItemListener.class, listener);
    }
    
    /** Removes ItemListener from the list of listeners.
     * @param listener The listener to remove.
     */
    public synchronized void removeItemListener(java.awt.event.ItemListener listener) {
        listenerList.remove(java.awt.event.ItemListener.class, listener);
    }
    
    /** Notifies all registered listeners about the event.
     *
     * @param e The event to be fired
     */
    private void fireItemListenerItemStateChanged(java.awt.event.ItemEvent event) {
        if (listenerList == null) return;
        Object[] listeners = listenerList.getListenerList();
        for (int i = listeners.length-2; i>=0; i-=2) {
            if (listeners[i]==java.awt.event.ItemListener.class) {
                ((java.awt.event.ItemListener)listeners[i+1]).itemStateChanged(event);
            }
        }
    }

}
