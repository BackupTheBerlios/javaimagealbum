/*
 * <license>
 * The contents of this file are subject to the Mozilla Public License 
 * Version 1.1 (the "License"); you may not use this file except in 
 * compliance with the License.  You may obtain a copy of the License 
 * at http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an 
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or 
 * implied. See the License for the specific language governing rights 
 * and limitations under the License.
 * 
 * The Original Code is Web Photo Publisher.
 * 
 * The Initial Developer of the Original Code is Mark Roth.  Portions 
 * created by Mark Roth are Copyright (C) 2003 Mark Roth.  
 * All Rights Reserved.
 * 
 * Contributor(s) listed below.
 * </license>
 */

package com.javaimagealbum;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;

/**
 * Panel that displays a preview of an image
 *
 * @author  Mark Roth
 * @author  Mirko Actis
 */
public class ImagePreviewPanel extends javax.swing.JPanel {

    /** Creates new form PreviewPanel */
    public ImagePreviewPanel() {
        initComponents ();
        startPreviewThread();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the FormEditor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents

        setLayout(new java.awt.BorderLayout());

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });

    }//GEN-END:initComponents

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        // If we're resized, our cache is no longer valid.
        invalidateCache();
        setImage( imageFile );
    }//GEN-LAST:event_formComponentResized


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    // True while the preview thread is to continue scanning
    // for image files to load.
    private boolean previewThreadAlive = false;
    
    // The image file to load
    private File imageFile = null;
    
    // Original BufferedImage used to read the thumbnail
    private BufferedImage lastThumbnailBuffer = null;
    
    // The current image to display in the preview panel
    private BufferedImage previewImage = null;
    
    // An object to synchronize threads
    private Object imageFileChanged = new Object();
    
    // By when to display the next preview
    private long changeTime;
    
    // The amount of time to wait before an image filename
    // change and a preview load.
    private static final int TIME_DELAY = 250;
    
    // The current state:
    private int state = STATE_BLANK;
    
    // The various states this preview can be in:
    private static final int STATE_BLANK   = 0;
    private static final int STATE_LOADING = 1;
    private static final int STATE_IMAGE   = 2;
    private static final int STATE_INVALID = 3;
    
    // The initial size of the thumbnail image cache (number of images):
    private static final int INITIAL_CACHE_SIZE = 50;
    
    // A cache of files and their rendered thumbnails:
    private ThumbnailCache cache = new ThumbnailCache( INITIAL_CACHE_SIZE );
    
    // True if this panel has been painted at least once.  This is kept
    // track of so we can tell if we know our final size.
    private boolean wasPainted = false;
    
    // If true, we can start loading images in the background.  If false,
    // we should immediately stop doing so.
    private boolean keepLoading = false;
    
    
    /**
     * Sets the image for this preview to the given file.
     * In a separate Thread, the given file is loaded.  When
     * the file is finished loading, it is displayed in
     * the preview panel.  In the meanwhile, the panel is
     * left empty.
     */
    public void setImage( File file ) {
        this.imageFile = file;
        if( file == null ) {
            setImage( (BufferedImage)null );
        }
        else {
            // If the image is in the cache, show it immediately:
            BufferedImage image = cache.getImage( file.getAbsolutePath() );
            if( image != null ) {
                setImage( image );
            }
            else {
                // Clear the image:
                setImage( (BufferedImage)null );

                if( file != null ) {
                    // Next, schedule the image for showing:
                    this.changeTime = System.currentTimeMillis() + TIME_DELAY;
                    synchronized( imageFileChanged ) {
                        imageFileChanged.notifyAll();
                    }
                }
            }
        }
    }
    
    /**
     * Changes the image to be previewed.  The changes are
     * reflected immediately.
     *
     * @param thumbnail The thumbnail to display
     */
    public void setImage( BufferedImage thumbnail ) {
        if( thumbnail != null ) {
            state = STATE_IMAGE;
        }
        else {
            state = STATE_BLANK;
        }
        
        this.previewImage = thumbnail;
        repaint();
    }
    
    public void paint( Graphics g ) {
        wasPainted = true;
        
        Dimension size = getSize();
        g.setColor( getBackground() );
        g.fillRect( 0, 0, size.width, size.height );
        
        if( isEnabled() ) {
            switch( state ) {
            case STATE_BLANK:
                paintBlank( g );
                break;
            case STATE_LOADING:
                paintLoading( g );
                break;
            case STATE_IMAGE:
                paintImage( g );
                break;
            case STATE_INVALID:
                paintInvalid( g );
                break;
            }
        }
        else {
            paintBlank( g );
        }
    }
    
    private void paintBlank( Graphics g ) {
        drawText( g, "" );
    }
    
    private void paintLoading( Graphics g ) {
        drawText( g, "Loading Preview..." );
    }
    
    private void paintImage( Graphics g ) {
        g.drawImage( previewImage, 0, 0, null );
    }
    
    private void paintInvalid( Graphics g ) {
        drawText( g, "Not a Photo." );
    }
    
    private void drawText( Graphics g, String text ) {
        g.setColor( Color.black );
        Dimension size = getSize();
        int textWidth = g.getFontMetrics().stringWidth( text );
        int textHeight = g.getFontMetrics().getHeight();
        
        g.drawString( 
            text,
            (size.width - textWidth) / 2,
            (size.height + textHeight) / 2 );
            
    }
        
    private void stopPreviewThread() {
        previewThreadAlive = false;
        synchronized( imageFileChanged ) {
            imageFileChanged.notifyAll();
        }
        if( this.lastThumbnailBuffer != null ) {
            this.lastThumbnailBuffer.flush();
            this.lastThumbnailBuffer = null;
        }
    }
    
    private void startPreviewThread() {
        previewThreadAlive = true;
        
        new Thread() {
            public void run() {
                // Keep track of the file we just loaded to see if we
                // can rest or if we have to load another one.
                File justLoaded = null;
                do {
                    if( imageFile == justLoaded ) {
                        try {                    
                            synchronized( imageFileChanged ) {
                                imageFileChanged.wait();
                            }
                        }
                        catch( InterruptedException e ) {
                        }
                    }
                    justLoaded = imageFile;
                    
                    // Wait a second for the user to make up his/her mind:
                    while( System.currentTimeMillis() < changeTime ) {
                        try {
                            Thread.sleep( changeTime - 
                                System.currentTimeMillis() );
                        }
                        catch( InterruptedException e ) {
                        }
                    }
                    
                    if( imageFile == null ) {
                        setImage( (BufferedImage)null );
                    }
                    else {
                        try {
                            String key = imageFile.getAbsolutePath();
                            BufferedImage cachedImage = cache.getImage( key );
                            if( cachedImage == null ) {
                                // Image is not in cache.  Load it:
                                state = STATE_LOADING;
                                repaint();
                                loadAndCache( justLoaded );
                                setImage( imageFile );
                            }
                            else {
                                // Image is in cache.
                                setImage( cachedImage );
                            }
                        }
                        catch( IOException e ) {
                            state = STATE_INVALID;
                            repaint();
                        }
                    }
                } while( previewThreadAlive );
            }
        }.start();
    }
    
    /**
     * Returns the number of available cache slots
     */
    public int getAvailableCache() {
        return cache.available();
    }
    
    /**
     * Suggests a list of files to cache in the background, 
     * to fill up cache slots.
     */
    public void suggestList( final File[] fileList ) {
        Thread suggestThread = new Thread() {
            public void run() {
                for( int i = 0; keepLoading && (i < fileList.length); i++ ) {
                    if( cache.available() > 0 ) {
                        try {
                            loadAndCache( fileList[i] );
                        }
                        catch( IOException e ) {
                            // Couldn't cache this one.  Ignore.
                        }
                    }
                }
            }
        };
        // This is a background thread, so keep it minimum priority.
        suggestThread.setPriority( Thread.MIN_PRIORITY );
        suggestThread.start();
    }
    
    /**
     * Invalidate the cache to make room for more relevant images.
     */
    public void invalidateCache() {
        cache.invalidate();
    }
    
    /**
     * Tells the preview panel whether to keep loading images in the
     * background.  If false, all background image loading will stop.
     * If true, background image loading will continue
     */
    public void setKeepLoading( boolean keepLoading ) {
        this.keepLoading = keepLoading;
    }
    
    /**
     * Loads and caches the given image file, if it's not already
     * cached.
     */
    private synchronized void loadAndCache( File imageFile ) 
        throws IOException
    {
        // Even if caller does this, it's important that we check again,
        // because this method is synchronized and called from numerous
        // Threads.
        String key = imageFile.getAbsolutePath();
        BufferedImage cachedImage = cache.getImage( key );
        if( cachedImage == null ) {
            Dimension panelSize = getSize();
            BufferedImage outImage = 
                GUIUtils.loadImageFromFile( imageFile, lastThumbnailBuffer,
                panelSize, panelSize );
            lastThumbnailBuffer = outImage;
            cachedImage = GUIUtils.createThumbnail( 
                outImage, 
                null, 
                panelSize.width, panelSize.height,
                panelSize.width, panelSize.height,
                true );
            cache.addImage( key, cachedImage );
        }
    }
    
    /**
     * An MRU cache of thumbnails
     */
    private class ThumbnailCache {
        // Key = thumbnail key, value = Image
        private Hashtable images;
        
        // Most recently used images are at the end of this Vector
        private Vector mruList;
        
        // How many images to store
        private int size;
        
        public ThumbnailCache( int initialSize ) {
            size = initialSize;
            mruList = new Vector( size );
            images = new Hashtable( size );
        }
        
        /**
         * Returns the image with the given key, if it is in the cache.
         * If it's not in the cache, null is returned.
         */
        public synchronized BufferedImage getImage( String key ) {
            BufferedImage result = null;
            if( images.containsKey( key ) ) {
                result = (BufferedImage)images.get( key );
                
                // Move this image to the front of the MRU list:
                int index = mruList.indexOf( key );
                mruList.removeElementAt( index );
                mruList.addElement( key );
            }
            
            return result;
        }
        
        /**
         * Adds the given image to the cache.  If the key already exists,
         * the Image is updated.  If the key doesn't exist, the least
         * recently used image is tossed, and this image is added.
         */
        public synchronized void addImage( String key, BufferedImage image ) {
            if( images.containsKey( key ) ) {
                images.put( key, image );
            }
            else {
                // Destroy old image:
                if( mruList.size() == size ) {
                    String oldKey = (String)mruList.elementAt( 0 );
                    Image img = (Image)images.get( oldKey );
                    img.flush();
                    images.remove( oldKey );
                    mruList.removeElementAt( 0 );
                }
                
                // Add new image:
                images.put( key, image );
                mruList.addElement( key );
            }
        }
        
        /**
         * Invalidates all images in the cache
         */
        public synchronized void invalidate() {
            for( int i = 0; i < mruList.size(); i++ ) {
                String key = (String)mruList.elementAt( i );
                BufferedImage image = (BufferedImage)images.get( key );
                image.flush();
            }
            mruList.clear();
            images.clear();
        }
        
        /**
         * Returns number of available cache slots
         */
        public int available() {
            return size - mruList.size();
        }
    }
}
